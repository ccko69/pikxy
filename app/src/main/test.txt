

       <ScrollView
             android:layout_height="wrap_content"
             android:layout_width="match_parent"
             android:scrollbars="vertical"
             android:scrollbarSize="4dp"
             android:clickable="true"
             android:clipToPadding="false"
             android:isScrollContainer="@+id/recyclerViewPhotos"
             android:focusable="auto"
             android:scrollIndicators="end">
             
    <androidx.recyclerview.widget.RecyclerView
            android:layout_height="match_parent"
            android:layout_width="match_parent"
            android:scrollbars="vertical"
            android:scrollbarSize="8dp"
            android:clipToPadding="false"
            android:scrollbarThumbVertical="@mipmap/scrollbar_thumb"
			android:scrollbarDefaultDelayBeforeFade="5"
			app:fastScrollEnabled="true"
			app:fastScrollVerticalThumbDrawable="@mipmap/scrollbar_thumb"
			app:fastScrollVerticalTrackDrawable="@mipmap/scrollbar_track"
			android:scrollbarTrackVertical="@mipmap/scrollbar_track"
            android:scrollIndicators="right"
            android:background="#CC161616"
            android:padding="4dp"
            android:id="@+id/recyclerViewPhotos" />
            
        
        <?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/seekbar_thumb.webp" />
    <foreground android:drawable="@drawable/seekbar_thumb.webp" />
</adaptive-icon>


java.lang.RuntimeException: Canvas: trying to draw too large(122880000bytes) bitmap.
	at android.graphics.RecordingCanvas.throwIfCannotDraw(RecordingCanvas.java:280)
	at android.graphics.BaseRecordingCanvas.drawBitmap(BaseRecordingCanvas.java:88)
	at android.graphics.drawable.BitmapDrawable.draw(BitmapDrawable.java:548)

	


import android.content.pm.ActivityInfo;
import android.os.Bundle;
import androidx.appcompat.app.AppCompatActivity;
import com.google.android.material.floatingactionbutton.FloatingActionButton;



  private int originalOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    fabBtn = findViewById(R.id.viewModeButton);

    fabBtn.setOnClickListener(
        v -> {
          toggleOrientation();
        });
  }

  // Toggle orientation

  private void toggleOrientation() {
    if (getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) {
      setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
    } else {
      setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
    }
  }


        	
	
private int originalOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;

	
	
	
		// Toggle orientation
		if (id == R.id.nav_orientation) {
			toggleOrientation();
			return true;
		}
		
		private void toggleOrientation() {
		if (getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) {
			setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
		} else {
			setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
		}
	}
    
    
    // ============
    // slider instead of seekbar
    
      <com.google.android.material.slider.Slider
                 android:layout_height="wrap_content"
                 android:layout_width="0dp"
                 app:thumbRadius="10dp"
                 android:clickable="true"
                 app:minTouchTargetSize="60dp"
                 app:thumbStrokeColor="#B00020"
                 android:focusable="true"
                 android:layout_gravity="center"
                 app:thumbColor="#FFFFFF"
                 app:haloColor="#77B00020"
                 android:minHeight="25dp"
                 app:trackColor="@color/gray_600"
                 android:paddingBottom="8dp"
                 android:splitTrack="false"
                 app:trackColorActive="#B00020"
                 app:trackHeight="6dp"
                 app:thumbStrokeWidth="1dp"
                 android:layout_weight="1"
                 app:haloRadius="60dp"
                 android:id="@+id/vidSliderBar" />

            <SeekBar
                android:id="@+id/videoSeekBar"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:maxHeight="3dp"
                android:minHeight="2dp"
                android:paddingBottom="8dp"
                android:paddingTop="8dp"
                android:progressDrawable="@drawable/seekbar_progress"
                android:splitTrack="false"
                android:thumb="@drawable/seekbar_thumb"
            />


 <View
             android:layout_height="0dp"
             android:layout_width="0dp"
             android:background="@drawable/gradient_overlay"
             app:layout_constraintTop_toTopOf="parent"
             app:layout_constraintStart_toStartOf="parent"
             app:layout_constraintEnd_toEndOf="parent"
             app:layout_constraintBottom_toBottomOf="parent"
             android:id="@+id/overlay" />
             
             
          
          
          
          
          
              // rotation fields
                  private StyledPlayerView videoPlayerView;
              
    private int rotationSteps = 0;
    private static final int ROTATION_DURATION = 500;
    
    
          // button
       rotateButton.setOnClickListener(
                v -> {
                    rotationSteps = (rotationSteps + 1) % 4; // counter-clockwise
                        applyRotationAnimated();
                });
                    

how should i apply rotation to imageView's content instead of imageView itself in this code?
(use the example for better understanding.)
here's the code:

   // Apply rotation to imageView
    private void applyRotationAnimated() {
        if (imageView == null) return;

        float targetAngle = rotationSteps * 90f;
        float currentAngle = imageView.getRotation();

        // 1. Animate rotation
        ObjectAnimator rotationAnim =
                ObjectAnimator.ofFloat(imageView, "rotation", currentAngle, targetAngle);
        rotationAnim.setDuration(ROTATION_DURATION); // 500
        rotationAnim.setInterpolator(new DecelerateInterpolator());
        rotationAnim.start();

        // 2. ANIMATE CLAMP (runs in parallel with rotation)
        animateClamp();

    }

    // Smooth animated clamp 
    private void animateClamp() {
        View parent = (View) imageView.getParent();
        if (parent == null || parent.getWidth() == 0 || parent.getHeight() == 0) {
            // Parent not ready → retry after layout
            parent.post(this::animateClamp);
            return;
        }

        // Get current dimensions
        ViewGroup.LayoutParams lp = imageView.getLayoutParams();
        int startWidth = lp.width;
        int startHeight = lp.height;

        // Calculate target dimensions
        int pw = parent.getWidth();
        int ph = parent.getHeight();
        boolean swap = (rotationSteps % 2) != 0;
        int targetWidth = swap ? ph : pw;
        int targetHeight = swap ? pw : ph;

        // Skip if no change needed
        if (startWidth == targetWidth && startHeight == targetHeight) return;

        // Animate width/height change over ROTATION_DURATION
        ValueAnimator layoutAnim = ValueAnimator.ofFloat(0f, 1f);
        layoutAnim.setDuration(ROTATION_DURATION);
        layoutAnim.setInterpolator(new DecelerateInterpolator());
        layoutAnim.addUpdateListener(
                animation -> {
                    float fraction = animation.getAnimatedFraction();
                    int animatedWidth = (int) (startWidth + (targetWidth - startWidth) * fraction);
                    int animatedHeight =
                            (int) (startHeight + (targetHeight - startHeight) * fraction);

                    ViewGroup.LayoutParams animLp = imageView.getLayoutParams();
                    animLp.width = animatedWidth;
                    animLp.height = animatedHeight;
                    imageView.setLayoutParams(animLp);
                });
        layoutAnim.start();
    }
    // Example: an example of how i handle imageView's content instead of the imageView itself.
    @Override
              public void onScale(float scaleDelta, float focusX, float focusY) {
                if (imageView != null) {
                  imageView.post(
                      () -> {
                        float newScale = scaleFactor * scaleDelta;
                        newScale = Math.max(minTempScale, Math.min(newScale, 30.0f));
                        if (newScale != scaleFactor) {
                          float appliedDelta = newScale / scaleFactor;
                          scaleFactor = newScale;
                          imageMatrix.postScale(appliedDelta, appliedDelta, focusX, focusY);
                          clampMatrix();
                          imageView.setImageMatrix(imageMatrix);
                        }
                      });
                }
              }
    
    // on destroy 
      if (videoPlayerView != null) {
      videoPlayerView.clearAnimation(); // Cancel rotation animation
      // Cancel clamp animation (if any)
      videoPlayerView.animate().cancel();
    }
    
    //============
    //============


private float getCurrentRotationFromMatrix(Matrix matrix) {
    float[] values = new float[9];
    matrix.getValues(values);
    return (float) Math.toDegrees(Math.atan2(values[Matrix.MSKEW_Y], values[Matrix.MSCALE_X]));
}

private void applyRotationAnimated() {
    if (imageView == null) return;

    float targetAngle = rotationSteps * 90f;
    float currentAngle = getCurrentRotationFromMatrix(imageMatrix); // تابع جدید

    // 1. Animate rotation of content (not imageView itself)
    ValueAnimator rotationAnim = ValueAnimator.ofFloat(currentAngle, targetAngle);
    rotationAnim.setDuration(ROTATION_DURATION);
    rotationAnim.setInterpolator(new DecelerateInterpolator());
    rotationAnim.addUpdateListener(animation -> {
        float angle = (float) animation.getAnimatedValue();
        imageMatrix.reset();
        imageMatrix.postRotate(angle, imageView.getWidth() / 2f, imageView.getHeight() / 2f);
        clampMatrix(); // اگر داری از clamp استفاده می‌کنی
        imageView.setImageMatrix(imageMatrix);
    });
    rotationAnim.start();

    // 2. ANIMATE CLAMP (runs in parallel with rotation)
    animateClamp();
}

private void animateClamp() {
    View parent = (View) imageView.getParent();
    if (parent == null || parent.getWidth() == 0 || parent.getHeight() == 0) {
        // Parent not ready → retry after layout
        parent.post(this::animateClamp);
        return;
    }

    // Get current rotation angle from matrix
    float currentRotation = getCurrentRotationFromMatrix(imageMatrix);

    // Calculate target rotation
    float targetRotation = rotationSteps * 90f;

    // Skip if no change needed
    if (Math.abs(currentRotation - targetRotation) < 1f) return;

    // Animate rotation of content (not imageView itself)
    ValueAnimator rotationAnim = ValueAnimator.ofFloat(currentRotation, targetRotation);
    rotationAnim.setDuration(ROTATION_DURATION);
    rotationAnim.setInterpolator(new DecelerateInterpolator());
    rotationAnim.addUpdateListener(animation -> {
        float angle = (float) animation.getAnimatedValue();
        imageMatrix.reset();
        imageMatrix.postRotate(angle, imageView.getWidth() / 2f, imageView.getHeight() / 2f);
        clampMatrix(); // اگر داری از clamp استفاده می‌کنی
        imageView.setImageMatrix(imageMatrix);
    });
    rotationAnim.start();

    // Optional: animate scale to 1.0f if needed
    if (scaleFactor < 1.0f) {
        animateScaleTo(1.0f);
    }
}

============✓✓

i want to use a custom Slider for my videoplayer instead of the custom seekBar that I'm currently using.
i want you rewrite my code, so it's compatible with the Slider (com.google.android.material.slider.Slider).

// Example: this is the listeners and helpers for videoplayer's seekbar:
// listeners.
seekBar.setOnSeekBarChangeListener(
        new SeekBar.OnSeekBarChangeListener() {
          @Override
          public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
            if (fromUser && !isUiLocked) {
              currentTime.setText(formatTime(progress));
              FcurrentTime.setText(formatTime(progress));
            }
          }

          @Override
          public void onStartTrackingTouch(SeekBar seekBar) {
            // Pause auto-hide while seeking
          }

          @Override
          public void onStopTrackingTouch(SeekBar seekBar) {
            if (!isUiLocked && listener != null) {
              listener.onSeekTo(seekBar.getProgress());
            }
          }
        });
// helpers.
public void updateProgress(long currentMs, long durationMs) {
    if (durationMs > 0) {
      seekBar.setMax((int) durationMs);
      seekBar.setProgress((int) currentMs);

      currentTime.setText(formatTime(currentMs));
      totalTime.setText(formatTime(durationMs));

      FcurrentTime.setText(formatTime(currentMs));
      FtotalTime.setText(formatTime(durationMs));
    }
  }
  
  
  
  
  
  <com.google.android.material.slider.Slider
    android:id="@+id/vidSliderBar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginStart="16dp"
    android:layout_marginEnd="16dp"
    app:trackPosition="top"
    app:thumbColor="@color/your_thumb_color"
    app:trackColorActive="@color/your_active_color"
    app:trackColorInactive="@color/your_inactive_color" />
    
    
    vidSliderBar.addOnSliderTouchListener(new Slider.OnSliderTouchListener() {
    @Override
    public void onSliderTouch(Slider slider, boolean isTouch) {
        if (isTouch) {
            // Pause auto-hide while seeking
        }
    }
});

vidSliderBar.addOnChangeListener(new Slider.OnChangeListener() {
    @Override
    public void onValueChange(Slider slider, float value, boolean fromUser) {
        if (fromUser && !isUiLocked) {
            currentTime.setText(formatTime((long) value));
            FcurrentTime.setText(formatTime((long) value));
        }
    }
});

vidSliderBar.addOnSliderTouchListener(new Slider.OnSliderTouchListener() {
    @Override
    public void onSliderTouch(Slider slider, boolean isTouch) {
        if (!isTouch && !isUiLocked && listener != null) {
            listener.onSeekTo((int) slider.getValue());
        }
    }
});


public void updateProgress(long currentMs, long durationMs) {
    if (durationMs > 0) {
        vidSliderBar.setValueFrom(0);
        vidSliderBar.setValueTo(durationMs);
        vidSliderBar.setValue(currentMs);

        currentTime.setText(formatTime(currentMs));
        totalTime.setText(formatTime(durationMs));

        FcurrentTime.setText(formatTime(currentMs));
        FtotalTime.setText(formatTime(durationMs));
    }
}



private String formatTime(long millis) {
    int seconds = (int) (millis / 1000) % 60;
    int minutes = (int) ((millis / 1000) / 60) % 60;
    return String.format("%02d:%02d", minutes, seconds);
}


videoSlider.addOnSliderTouchListener(new Slider.OnSliderTouchListener() {
    @Override
    public void onSliderTouch(Slider slider, boolean isTouch) {
        if (isTouch) {
            // Pause auto-hide while seeking
        } else {
            // User released the slider
            if (!isUiLocked && listener != null) {
                listener.onSeekTo((int) slider.getValue());
            }
        }
    }
});

videoSlider.addOnChangeListener(new Slider.OnChangeListener() {
    @Override
    public void onValueChange(Slider slider, float value, boolean fromUser) {
        if (fromUser && !isUiLocked) {
            currentTime.setText(formatTime((long) value));
            FcurrentTime.setText(formatTime((long) value));
        }
    }
});


private void loadImage(MediaItems item) {
    Log.d("ImageDebug", "Loading image: " + item.name);
    
    // ... existing code ...
    
    // In the thread, add:
    Bitmap bm = ImageLoader.decodeSampledBitmapFromUri(ctx, uri, 0, 0);
    if (bm != null) {
        Log.d("ImageDebug", "Bitmap size: " + bm.getWidth() + "x" + bm.getHeight() + 
              " (" + (bm.getWidth() * bm.getHeight() * 4 / (1024*1024)) + "MB)");
    }
}


nah, as you probably know, there's a internet blockage in my country.
so let's try something easy first.
-
i want my app to have full storage access but it's just asking for media right now.
take a look at this:
private void checkStoragePermission() {
    if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
        != PackageManager.PERMISSION_GRANTED) {

      if (ActivityCompat.shouldShowRequestPermissionRationale(
          this, Manifest.permission.READ_EXTERNAL_STORAGE)) {
        new AlertDialog.Builder(this)
            .setTitle("Storage Permission Needed")
            .setMessage("This app needs access to your photos to display them in your gallery.")
            .setPositiveButton(
                "OK",
                (dialog, which) ->
                    ActivityCompat.requestPermissions(
                        MainActivity.this,
                        new String[] {Manifest.permission.READ_EXTERNAL_STORAGE},
                        STORAGE_PERMISSION_CODE))
            .setNegativeButton("Cancel", (dialog, which) -> finish())
            .create()
            .show();
      } else {
        ActivityCompat.requestPermissions(
            this,
            new String[] {Manifest.permission.READ_EXTERNAL_STORAGE},
            STORAGE_PERMISSION_CODE);
      }
    }
  }

// and then this:
  @Override
  public void onRequestPermissionsResult(
      int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);

    if (requestCode == STORAGE_PERMISSION_CODE) {
      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
        Fragment currentFragment =
            getSupportFragmentManager().findFragmentById(R.id.fragmentContainer);
        if (currentFragment instanceof AlbumsFragment) {
          ((AlbumsFragment) currentFragment).loadAlbums();
        }
      } else {
        Toast.makeText(this, "Storage permission is required to view photos", Toast.LENGTH_LONG)
            .show();

        if (!ActivityCompat.shouldShowRequestPermissionRationale(
            this, Manifest.permission.READ_EXTERNAL_STORAGE)) {
          Toast.makeText(
                  this, "Please grant permission in Settings to use this app", Toast.LENGTH_LONG)
              .show();
          finish();
        } else {
          new Handler(Looper.getMainLooper())
              .postDelayed(
                  () ->
                      ActivityCompat.requestPermissions(
                          MainActivity.this,
                          new String[] {Manifest.permission.READ_EXTERNAL_STORAGE},
                          STORAGE_PERMISSION_CODE),
                  1000);
        }
      }
    }
  }
---
how should I change them to request for full storage access?

  
    // REPLACE checkStoragePermission: Added AlertDialog wrapper to handle the "Ask -> Settings" flow
  private void checkStoragePermission() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
      if (!Environment.isExternalStorageManager()) {
        new androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Permission Required")
            .setMessage("This app requires All Files Access to manage your albums. Please enable it in settings.")
            .setPositiveButton("Grant", (dialog, which) -> {
              try {
                Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);
                intent.addCategory("android.intent.category.DEFAULT");
                intent.setData(Uri.parse(String.format("package:%s", getApplicationContext().getPackageName())));
                startActivityForResult(intent, STORAGE_PERMISSION_CODE);
              } catch (Exception e) {
                Intent intent = new Intent();
                intent.setAction(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION);
                startActivityForResult(intent, STORAGE_PERMISSION_CODE);
              }
            })
            .setNegativeButton("Exit", (dialog, which) -> finish())
            .setCancelable(false)
            .show();
      } else {
        loadAlbumsIfPresent();
      }
    } else {
      // Legacy permissions for Android 10 and below
      if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
          != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(
            this,
            new String[] {Manifest.permission.READ_EXTERNAL_STORAGE},
            STORAGE_PERMISSION_CODE);
      } else {
        loadAlbumsIfPresent();
      }
    }
  }
  
  
    // REPLACE onActivityResult: Added logic to re-show dialog if permission is still missing
  @Override
  protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if (requestCode == STORAGE_PERMISSION_CODE) {
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
        if (Environment.isExternalStorageManager()) {
          // "Refresh" by loading the data
          loadAlbumsIfPresent();
        } else {
          // Re-trigger the dialog logic because they didn't grant it
          Toast.makeText(this, "Permission is mandatory to continue", Toast.LENGTH_SHORT).show();
          checkStoragePermission(); 
        }
      }
    }
  }
  
  
    // Call this from fragments using: ((MainActivity) getActivity()).toggleOrientation();
  public void toggleOrientation() {
    if (getRequestedOrientation() != ActivityInfo.SCREEN_ORIENTATION_PORTRAIT) {
      // If we aren't in portrait, force it back to portrait
      setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
    } else {
      // Switches to landscape AND allows sensor-based flipping (Landscape/Reverse Landscape)
      setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE);
    }
  }
  
  
  
      // Anchor: after initializing your EditText view
    yourEditText.setOnEditorActionListener((v, actionId, event) -> {
        // IME_ACTION_DONE is the standard "check" or "confirm" button on mobile keyboards
        if (actionId == EditorInfo.IME_ACTION_DONE || actionId == EditorInfo.IME_ACTION_GO) {
            toggleOrientation(); // Or whatever confirmation logic you need
            return true;
        }
        return false;
    });
    
    
    <?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="#2C2C2C"
    android:orientation="vertical"
    android:padding="24dp">

    <TextView
        android:id="@+id/dialog_title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:textColor="#FFFFFF"
        android:textSize="20sp"
        android:textStyle="bold" />

    <EditText
        android:id="@+id/dialog_input"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:background="#333333"
        android:gravity="center"
        android:imeOptions="actionDone"
        android:inputType="numberDecimal"
        android:padding="12dp"
        android:textColor="#FFFFFF" />
</LinearLayout>


  private void askForSlideShowInterval() {
    // Inflate our new master layout
    View dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.layout_dialog_base, null);
    TextView titleView = dialogView.findViewById(R.id.dialog_title);
    EditText input = dialogView.findViewById(R.id.dialog_input);

    // Setup local info
    titleView.setText("Second per Slide");
    int lastSec = MainActivity.prefs.getInt("slideshow_delay", 5);
    input.setText(String.valueOf(lastSec));
    input.requestFocus();

    AlertDialog dialog = new AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .setPositiveButton("▶", (d, i) -> performSlideshowStart(input, lastSec))
            .setNegativeButton("X", null)
            .create();

    // KEYBOARD CONFIRMATION: This is the "Confirm from keyboard" part
    input.setOnEditorActionListener((v, actionId, event) -> {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            performSlideshowStart(input, lastSec);
            dialog.dismiss(); // Manually dismiss since we aren't clicking the button
            return true;
        }
        return false;
    });

    if (dialog.getWindow() != null) {
        dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
        // Apply the 50% width rule here
        dialog.show();
        int width = (int) (getResources().getDisplayMetrics().widthPixels * 0.5);
        dialog.getWindow().setLayout(width, WindowManager.LayoutParams.WRAP_CONTENT);
        dialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); // Layout handles color
    }

    // Style buttons
    dialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(Color.parseColor("#4CAF50"));
    dialog.getButton(AlertDialog.BUTTON_NEGATIVE).setTextColor(Color.parseColor("#F44336"));
    
        // Focus the input
    input.requestFocus();
    input.selectAll();
  }

  // Helper to avoid repeating logic for button vs keyboard
  private void performSlideshowStart(EditText input, int lastSec) {
    String txt = input.getText().toString().trim();
    int sec = txt.isEmpty() ? lastSec : Integer.parseInt(txt);
    MainActivity.prefs.edit().putInt("slideshow_delay", sec).apply();
    startSlideShow(sec);
  }
  
  
      // 1. Add to top of class
    private final List<Integer> passthroughViewIds = new ArrayList<>();
    private final Rect hitRect = new Rect();

    /**
     * Add IDs of views that should receive touches directly (e.g., R.id.btn_delete)
     */
    public void addPassthroughViewId(int id) {
        if (!passthroughViewIds.contains(id)) {
            passthroughViewIds.add(id);
        }
    }

    public void clearPassthroughViews() {
        passthroughViewIds.clear();
    }

    // 2. Add this helper method to check if a touch is hitting a "Passthrough" view
    private boolean isHittingPassthrough(MotionEvent ev) {
        if (passthroughViewIds.isEmpty()) return false;

        for (Integer id : passthroughViewIds) {
            View v = getRootView().findViewById(id);
            if (v != null && v.isShown()) {
                v.getGlobalVisibleRect(hitRect);
                if (hitRect.contains((int) ev.getRawX(), (int) ev.getRawY())) {
                    return true;
                }
            }
        }
        return false;
    }

    // 3. REPLACE your onInterceptTouchEvent with this version
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (currentDelegate == null) return false;
        if (isInDeadzone(ev)) return false;

        // NEW: If we are hitting a registered button/toolbar, don't intercept!
        if (isHittingPassthrough(ev)) {
            return false;
        }

        if (ev.getActionMasked() == MotionEvent.ACTION_DOWN) {
            return currentDelegate.wantsTouch(ev);
        }

        return true;
    }
    
    
    gestureOverlay.setGestureDelegate(imageViewerHandler);
gestureOverlay.addPassthroughViewId(R.id.delete_button);
gestureOverlay.addPassthroughViewId(R.id.top_toolbar);


android:layout_marginHorizontal="30dp"
			 android:layout_marginVertical="80dp"
             
             
                 <com.google.android.material.navigation.NavigationView
         android:layout_height="200dp"
         android:layout_width="150dp"
		 android:fitsSystemWindows="true"
		 android:textAlignment="center"
		 android:layout_marginTop="40dp"
         app:menu="@menu/drawer_nav_item"
		 app:itemTextColor="#900020"
		 app:drawerLayoutCornerSize="8dp"
		 app:itemBackground="?attr/selectableItemBackgroundBorderless"
		 app:itemIconTint="#B00020"
         android:id="@+id/nav_view"
		 android:background="#CC000000"
         android:layout_gravity="center_vertical|start">

    </com.google.android.material.navigation.NavigationView>
    
    
    // main activity.
    
    private DrawerLayout drawerLayout;
  private NavigationView navigationView;
  
  // onCreate.
    drawerLayout = findViewById(R.id.drawer_layout);
    navigationView = findViewById(R.id.nav_view);
    
     if (navigationView != null) {
      navigationView.setNavigationItemSelectedListener(
          this::onNavItemSelected); // Calls your method on item taps
    }
    
    drawerLayout.addDrawerListener(
        new DrawerLayout.DrawerListener() {
          @Override
          public void onDrawerSlide(View drawerView, float slideOffset) {}

          @Override
          public void onDrawerOpened(View drawerView) {}

          @Override
          public void onDrawerClosed(View drawerView) {}

          @Override
          public void onDrawerStateChanged(int newState) {}
        });
        
        // in the class.
         // 15. Menu / Nav handling
  public boolean onNavItemSelected(@NonNull MenuItem item) {
    // 15.1 Close drawer immediately
    if (drawerLayout != null) drawerLayout.closeDrawer(GravityCompat.START);

    int id = item.getItemId();

    // 15.6 Toggle orientation
    if (id == R.id.nav_orientation) {
      toggleOrientation();
      return true;
    }
    // 15.8 Placeholder for future options
    if (id == R.id.nav_more) {
      Toast.makeText(this, "More options not yet implemented.", Toast.LENGTH_SHORT).show();
      return true;
    }

    return false;
  }
  
  
  
  ==== ======== ============
  --++++++(+----&&__&--++--
popup_photos_sort.xml
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/bg_popup_round" 
    android:orientation="vertical"
    android:padding="8dp">

    <LinearLayout android:id="@+id/btn_sort_name" style="@style/SortRowStyle">
        <TextView android:id="@+id/txt_name" android:text="Name" style="@style/SortTextStyle"/>
        <ImageView android:id="@+id/img_name_arrow" android:src="@drawable/ic_arrow_up" style="@style/SortArrowStyle"/>
    </LinearLayout>

    <LinearLayout android:id="@+id/btn_sort_date" style="@style/SortRowStyle">
        <TextView android:id="@+id/txt_date" android:text="Date" style="@style/SortTextStyle"/>
        <ImageView android:id="@+id/img_date_arrow" android:src="@drawable/ic_arrow_down" style="@style/SortArrowStyle"/>
    </LinearLayout>

    <LinearLayout android:id="@+id/btn_sort_size" style="@style/SortRowStyle">
        <TextView android:id="@+id/txt_size" android:text="Size" style="@style/SortTextStyle"/>
        <ImageView android:id="@+id/img_size_arrow" android:src="@drawable/ic_arrow_down" style="@style/SortArrowStyle"/>
    </LinearLayout>
</LinearLayout>


floating_photos_viewmode.xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/bg_popup_round"
    android:orientation="vertical"
    android:padding="12dp">

    <RelativeLayout android:layout_width="match_parent" android:layout_height="48dp">
        <TextView android:text="Grid" android:layout_centerVertical="true" style="@style/SortTextStyle"/>
        <LinearLayout android:layout_alignParentEnd="true" android:layout_centerVertical="true" android:orientation="horizontal">
            <ImageButton android:id="@+id/btn_grid_minus" android:src="@drawable/ic_minus" style="@style/StepperButtonStyle"/>
            <TextView android:id="@+id/txt_grid_count" android:text="3" android:paddingHorizontal="12dp" style="@style/SortTextStyle"/>
            <ImageButton android:id="@+id/btn_grid_plus" android:src="@drawable/ic_plus" style="@style/StepperButtonStyle"/>
        </LinearLayout>
    </RelativeLayout>

    <RelativeLayout android:layout_width="match_parent" android:layout_height="48dp" android:alpha="0.5">
        <TextView android:text="Mosaic" android:layout_centerVertical="true" style="@style/SortTextStyle"/>
        <LinearLayout android:layout_alignParentEnd="true" android:layout_centerVertical="true" android:orientation="horizontal">
            <ImageButton android:src="@drawable/ic_minus" style="@style/StepperButtonStyle"/>
            <TextView android:text="3" android:paddingHorizontal="12dp" style="@style/SortTextStyle"/>
            <ImageButton android:src="@drawable/ic_plus" style="@style/StepperButtonStyle"/>
        </LinearLayout>
    </RelativeLayout>

    <LinearLayout android:id="@+id/btn_view_list" android:layout_width="match_parent" android:layout_height="48dp" android:gravity="center_vertical">
        <TextView android:text="List" style="@style/SortTextStyle"/>
    </RelativeLayout>
</LinearLayout>


  private enum SortMode {
    NAME_ASC, NAME_DESC,
    DATE_DESC, DATE_ASC, // Newest first (DESC) vs Oldest first (ASC)
    SIZE_DESC, SIZE_ASC
  }

  // Helper to handle background sorting for 21k items
  private void sortMediaList(List<MediaItems> list) {
    if (list == null || list.isEmpty()) return;
    switch (currentSortMode) {
      case NAME_ASC: list.sort(NATURAL_NAME_COMPARATOR); break;
      case NAME_DESC: list.sort(NATURAL_NAME_COMPARATOR.reversed()); break;
      case DATE_DESC: list.sort((a, b) -> Long.compare(b.dateModified, a.dateModified)); break;
      case DATE_ASC: list.sort((a, b) -> Long.compare(a.dateModified, b.dateModified)); break;
      case SIZE_DESC: list.sort((a, b) -> Long.compare(b.size, a.size)); break;
      case SIZE_ASC: list.sort((a, b) -> Long.compare(a.size, b.size)); break;
    }
  }
  
  
  
  
  
    private void showSortPopup(View anchor) {
    FloatingWindowManager fwm = new FloatingWindowManager(getContext(), anchor);
    fwm.show(R.layout.popup_photos_sort, dpToPx(220), ViewGroup.LayoutParams.WRAP_CONTENT, 10, Gravity.TOP | Gravity.END, content -> {
        
        // Setup rows
        setupSortRow(content.findViewById(R.id.btn_sort_name), R.id.img_name_arrow, SortMode.NAME_ASC, SortMode.NAME_DESC, fwm);
        setupSortRow(content.findViewById(R.id.btn_sort_date), R.id.img_date_arrow, SortMode.DATE_DESC, SortMode.DATE_ASC, fwm);
        setupSortRow(content.findViewById(R.id.btn_sort_size), R.id.img_size_arrow, SortMode.SIZE_DESC, SortMode.SIZE_ASC, fwm);
        
    }, false);
  }

  private void setupSortRow(View row, int arrowId, SortMode asc, SortMode desc, FloatingWindowManager fwm) {
    ImageView arrow = row.getRootView().findViewById(arrowId);
    
    // Set initial arrow state
    boolean isCurrentCategory = (currentSortMode == asc || currentSortMode == desc);
    arrow.setRotation(currentSortMode == asc ? 0 : 180);
    arrow.setAlpha(isCurrentCategory ? 1.0f : 0.3f);

    row.setOnClickListener(v -> {
        // Toggle direction if same category, otherwise default to primary (ASC/DESC based on type)
        if (currentSortMode == asc) currentSortMode = desc;
        else currentSortMode = asc;

        applySort(); // Re-sort and notify adapter
        fwm.updateContent(this::setupSortUI); // Refresh arrows in-place
    });
  }

  private void showViewModePopup(View anchor) {
    FloatingWindowManager fwm = new FloatingWindowManager(getContext(), anchor);
    fwm.show(R.layout.floating_photos_viewmode, dpToPx(250), ViewGroup.LayoutParams.WRAP_CONTENT, 10, Gravity.TOP | Gravity.END, content -> {
        
        TextView countTxt = content.findViewById(R.id.txt_grid_count);
        countTxt.setText(String.valueOf(currentSpanCount));

        content.findViewById(R.id.btn_grid_plus).setOnClickListener(v -> {
            if (currentSpanCount < 6) {
                updateGridSpan(++currentSpanCount);
                countTxt.setText(String.valueOf(currentSpanCount));
            }
        });

        content.findViewById(R.id.btn_grid_minus).setOnClickListener(v -> {
            if (currentSpanCount > 2) {
                updateGridSpan(--currentSpanCount);
                countTxt.setText(String.valueOf(currentSpanCount));
            }
        });

        content.findViewById(R.id.btn_view_list).setOnClickListener(v -> {
            isGridView = false;
            updateGridSpan(1);
            fwm.dismiss();
        });
    }, false);
  }

  private void updateGridSpan(int span) {
    isGridView = (span > 1);
    GridLayoutManager lm = (GridLayoutManager) recyclerView.getLayoutManager();
    if (lm != null) {
        lm.setSpanCount(span);
        adapter.notifyItemRangeChanged(1, adapter.getItemCount()); // Skip header, update grid
    }
  }
  
  
  
  
  
    private void showSortPopup(View anchor) {
    if (getContext() == null) return;
    
    FloatingWindowManager fwm = new FloatingWindowManager(getContext(), anchor);
    // Use DP conversion to ensure width is consistent across screens
    int widthPx = (int) (200 * getResources().getDisplayMetrics().density);

    fwm.show(R.layout.popup_photos_sort, widthPx, ViewGroup.LayoutParams.WRAP_CONTENT, 10, Gravity.TOP | Gravity.END, content -> {
        // IMPORTANT: Use 'content' to find views!
        View rowName = content.findViewById(R.id.btn_sort_name);
        View rowDate = content.findViewById(R.id.btn_sort_date);
        View rowSize = content.findViewById(R.id.btn_sort_size);

        setupSortRowLogic(content, rowName, R.id.img_name_arrow, SortMode.NAME_ASC, SortMode.NAME_DESC, fwm);
        setupSortRowLogic(content, rowDate, R.id.img_date_arrow, SortMode.DATE_DESC, SortMode.DATE_ASC, fwm);
        setupSortRowLogic(content, rowSize, R.id.img_size_arrow, SortMode.SIZE_DESC, SortMode.SIZE_ASC, fwm);
    }, false);
  }

  // Refactored for safety - 'content' is the inflated popup view
  private void setupSortRowLogic(View content, View row, int arrowId, SortMode asc, SortMode desc, FloatingWindowManager fwm) {
    ImageView arrow = content.findViewById(arrowId);
    
    boolean isCurrent = (currentSortMode == asc || currentSortMode == desc);
    arrow.setRotation(currentSortMode == asc ? 0 : 180);
    arrow.setAlpha(isCurrent ? 1.0f : 0.2f);

    row.setOnClickListener(v -> {
        currentSortMode = (currentSortMode == asc) ? desc : asc;
        
        // Instant response: sort first, then update UI
        applySort();
        
        // Refresh the popup UI without closing it
        fwm.updateContent(newContent -> {
            setupSortRowLogic(newContent, newContent.findViewById(row.getId()), arrowId, asc, desc, fwm);
        });
    });
  }

  private void showViewModePopup(View anchor) {
    if (getContext() == null) return;
    
    FloatingWindowManager fwm = new FloatingWindowManager(getContext(), anchor);
    int widthPx = (int) (240 * getResources().getDisplayMetrics().density);

    fwm.show(R.layout.popup_photos_view_mode, widthPx, ViewGroup.LayoutParams.WRAP_CONTENT, 10, Gravity.TOP | Gravity.END, content -> {
        TextView countTxt = content.findViewById(R.id.txt_grid_count);
        countTxt.setText(String.valueOf(currentSpanCount));

        content.findViewById(R.id.btn_grid_plus).setOnClickListener(v -> {
            if (currentSpanCount < 6) {
                currentSpanCount++;
                updateGridSpan(currentSpanCount);
                countTxt.setText(String.valueOf(currentSpanCount));
            }
        });

        content.findViewById(R.id.btn_grid_minus).setOnClickListener(v -> {
            if (currentSpanCount > 2) {
                currentSpanCount--;
                updateGridSpan(currentSpanCount);
                countTxt.setText(String.valueOf(currentSpanCount));
            }
        });

        content.findViewById(R.id.btn_view_list).setOnClickListener(v -> {
            isGridView = false;
            currentSpanCount = 1;
            updateGridSpan(1);
            fwm.dismiss();
        });
    }, false);
  }
  
  
  
  
  // Add this field at the top
private ImageMatrixController matrixController;

// In onCreateView, after initializing imageView:
matrixController = new ImageMatrixController(imageView);

// Replace the removed methods with controller calls:
private void updateImageMatrix() {
    // Replace: imageMatrix = computeInitialMatrix(imageView);
    Matrix matrix = matrixController.computeInitialMatrix(imageView);
    matrixController.setMatrix(matrix);
    
    // Update fragment's scaleFactor to match controller
    scaleFactor = matrixController.getScaleFactor();
    fitScale = matrixController.getFitScale();
}

// In onConfigurationChanged:
@Override
public void onConfigurationChanged(@NonNull Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    // Reset to fit on rotation
    if (imageView != null && imageView.getDrawable() != null) {
        Matrix matrix = matrixController.computeInitialMatrix(imageView);
        matrixController.setMatrix(matrix);
        imageView.setScaleType(ImageView.ScaleType.MATRIX);
    }
}

// In gesture callbacks, update matrix calls:
// Example in onPan:
@Override
public void onPan(float distanceX, float distanceY) {
    if (imageView != null) {
        imageView.post(() -> {
            if (scaleFactor > 1.01f) {
                Matrix current = matrixController.getMatrix();
                current.postTranslate(-distanceX, -distanceY);
                matrixController.setMatrix(current);
                matrixController.clampMatrix(); // Now calls controller method
            }
        });
    }
}

// Update scale callback:
@Override
public void onScale(float scaleDelta, float focusX, float focusY) {
    if (imageView != null) {
        imageView.post(() -> {
            float newScale = scaleFactor * scaleDelta;
            newScale = Math.max(minTempScale, Math.min(newScale, 30.0f));
            if (newScale != scaleFactor) {
                float appliedDelta = newScale / scaleFactor;
                scaleFactor = newScale;
                matrixController.setScaleFactor(scaleFactor);
                
                Matrix current = matrixController.getMatrix();
                current.postScale(appliedDelta, appliedDelta, focusX, focusY);
                matrixController.setMatrix(current);
                matrixController.clampMatrix(); // Use controller method
            }
        });
    }
}




@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    adapter = new PhotosAdapter(new PhotosAdapter.Callback() {
        @Override
        public void onMediaClicked(int index) {
            ViewerFragment vf = new ViewerFragment();
            Bundle args = new Bundle();
            args.putParcelableArrayList("media_items", new ArrayList<>(mediaList));
            args.putInt("current_index", index);
            vf.setArguments(args);

            ((MainActivity) requireActivity()).openViewer(vf);
        }

        @Override
        public void onSortClicked(View anchor) {
            showSortPopup(anchor);
        }

        @Override
        public void onViewModeClicked(View anchor) {
            toggleViewMode();
        }
    });
}

@Override
public View onCreateView(
        @NonNull LayoutInflater inflater,
        ViewGroup container,
        Bundle savedInstanceState
) {
    return inflater.inflate(R.layout.fragment_photos, container, false);
}

@Override
public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
    recyclerView = view.findViewById(R.id.recyclerView);

    GridLayoutManager lm = new GridLayoutManager(getContext(), 3);
    lm.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
        @Override
        public int getSpanSize(int position) {
            return position == 0 ? 3 : 1;
        }
    });

    recyclerView.setLayoutManager(lm);
    recyclerView.setAdapter(adapter);

    adapter.showLoading();

    loadAlbumPhotos(); // when done → adapter.submitMedia(...)
}